name: üßπ PR Consolidation & Cleanup

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (analyze only, do not close PRs)'
        required: true
        type: boolean
        default: true
      auto_cleanup_comments:
        description: 'Automatically clean up comments after consolidation'
        required: true
        type: boolean
        default: true
      auto_rerun_pipeline:
        description: 'Automatically re-run AI review pipeline after cleanup'
        required: true
        type: boolean
        default: true

permissions:
  contents: write
  pull-requests: write
  actions: write

jobs:
  analyze-prs:
    name: Phase 1 - Analyze & Consolidate PRs
    runs-on: ubuntu-latest
    outputs:
      prs_to_close: ${{ steps.analyze.outputs.prs_to_close }}
      prs_to_keep: ${{ steps.analyze.outputs.prs_to_keep }}
      consolidation_report: ${{ steps.analyze.outputs.report }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Analyze PRs and identify duplicates
        id: analyze
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            
            // Fetch all open PRs
            console.log('üì• Fetching all open pull requests...');
            const allPRs = [];
            let page = 1;
            while (true) {
              const { data } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100,
                page: page
              });
              
              if (data.length === 0) break;
              allPRs.push(...data);
              page++;
            }
            
            console.log(`Found ${allPRs.length} open PRs`);
            
            // Categorize PRs by what they're fixing
            const categories = {
              'governance-hook-mutations': {
                keywords: ['governance', 'before_tool', 'hook', 'mutate', 'mutation', 're-evaluate'],
                prs: []
              },
              'lease-overuse': {
                keywords: ['lease', 'overuse', 'concurrent', 'race', 'reserve', 'refund', 'consume'],
                prs: []
              },
              'import-fixes': {
                keywords: ['modulenotfound', 'import', 'src.meta_mcp', 'meta_mcp.config'],
                prs: []
              },
              'test-fixes': {
                keywords: ['test', 'pytest', 'automated tests'],
                prs: []
              },
              'command-execution': {
                keywords: ['command', 'execute_command', 'subprocess', 'command_runner'],
                prs: []
              },
              'discovery-registry': {
                keywords: ['discovery', 'registry', 'tool_registry', 'bootstrap'],
                prs: []
              },
              'elicitation': {
                keywords: ['elicit', 'approval', 'fastmcp', 'structured response'],
                prs: []
              },
              'pipeline-workflow': {
                keywords: ['ai agent pipeline', 'workflow', 'ai-pr-review', 'secret'],
                prs: []
              },
              'other': {
                keywords: [],
                prs: []
              }
            };
            
            // Categorize each PR
            for (const pr of allPRs) {
              const text = `${pr.title} ${pr.body || ''}`.toLowerCase();
              let categorized = false;
              
              for (const [category, config] of Object.entries(categories)) {
                if (category === 'other') continue;
                
                if (config.keywords.some(keyword => text.includes(keyword))) {
                  config.prs.push(pr);
                  categorized = true;
                  break;
                }
              }
              
              if (!categorized) {
                categories.other.prs.push(pr);
              }
            }
            
            // For each category, pick the best PR and mark others for closure
            const prsToKeep = [];
            const prsToClose = [];
            
            for (const [category, config] of Object.entries(categories)) {
              if (config.prs.length === 0) continue;
              
              console.log(`\nüìÇ Category: ${category} (${config.prs.length} PRs)`);
              
              if (config.prs.length === 1) {
                // Only one PR, keep it
                prsToKeep.push(config.prs[0].number);
                console.log(`  ‚úÖ Keep PR #${config.prs[0].number} (only one in category)`);
                continue;
              }
              
              // Score each PR based on quality indicators
              const scoredPRs = config.prs.map(pr => {
                let score = 0;
                
                // Prefer non-draft PRs
                if (!pr.draft) score += 10;
                
                // Prefer PRs targeting main branch
                if (pr.base.ref === 'main') score += 20;
                
                // Prefer PRs with more detailed descriptions
                score += Math.min((pr.body || '').length / 100, 10);
                
                // Prefer more recent PRs
                const daysOld = (Date.now() - new Date(pr.created_at)) / (1000 * 60 * 60 * 24);
                score += Math.max(10 - daysOld, 0);
                
                // Prefer PRs with assignees/reviewers (human attention)
                if (pr.assignees?.length > 0) score += 5;
                if (pr.requested_reviewers?.length > 0) score += 5;
                
                // Penalize PRs created by bots
                if (pr.user.type === 'Bot') score -= 5;
                
                return { pr, score };
              });
              
              // Sort by score descending
              scoredPRs.sort((a, b) => b.score - a.score);
              
              // Keep the best one
              const best = scoredPRs[0].pr;
              prsToKeep.push(best.number);
              console.log(`  ‚úÖ Keep PR #${best.number} "${best.title}" (score: ${scoredPRs[0].score.toFixed(1)})`);
              
              // Mark others for closure
              for (let i = 1; i < scoredPRs.length; i++) {
                prsToClose.push({
                  number: scoredPRs[i].pr.number,
                  title: scoredPRs[i].pr.title,
                  reason: `Duplicate of PR #${best.number}`,
                  category: category,
                  score: scoredPRs[i].score
                });
                console.log(`  ‚ùå Close PR #${scoredPRs[i].pr.number} (duplicate, score: ${scoredPRs[i].score.toFixed(1)})`);
              }
            }
            
            // Generate report
            const report = {
              total_prs: allPRs.length,
              prs_to_keep: prsToKeep.length,
              prs_to_close: prsToClose.length,
              categories: Object.entries(categories).map(([name, config]) => ({
                name,
                count: config.prs.length
              })).filter(c => c.count > 0)
            };
            
            console.log('\nüìä Consolidation Summary:');
            console.log(`  Total PRs: ${report.total_prs}`);
            console.log(`  PRs to keep: ${report.prs_to_keep}`);
            console.log(`  PRs to close: ${report.prs_to_close}`);
            
            // Save outputs
            core.setOutput('prs_to_keep', JSON.stringify(prsToKeep));
            core.setOutput('prs_to_close', JSON.stringify(prsToClose));
            core.setOutput('report', JSON.stringify(report));
            
            // Save detailed report as artifact
            fs.writeFileSync('consolidation-report.json', JSON.stringify({
              report,
              prs_to_keep: prsToKeep,
              prs_to_close: prsToClose
            }, null, 2));
      
      - name: Upload consolidation report
        uses: actions/upload-artifact@v4
        with:
          name: consolidation-report
          path: consolidation-report.json
          retention-days: 30
  
  close-duplicate-prs:
    name: Phase 1 - Close Duplicate PRs
    needs: analyze-prs
    runs-on: ubuntu-latest
    if: inputs.dry_run == false
    
    steps:
      - name: Close duplicate PRs
        uses: actions/github-script@v7
        with:
          script: |
            const prsToClose = JSON.parse('${{ needs.analyze-prs.outputs.prs_to_close }}');
            
            if (prsToClose.length === 0) {
              console.log('No PRs to close');
              return;
            }
            
            console.log(`Closing ${prsToClose.length} duplicate PRs...`);
            
            for (const prInfo of prsToClose) {
              try {
                // Add explanatory comment
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prInfo.number,
                  body: [
                    '## ü§ñ Automated PR Consolidation',
                    '',
                    `This PR is being closed as a duplicate.`,
                    '',
                    `**Reason:** ${prInfo.reason}`,
                    `**Category:** ${prInfo.category}`,
                    '',
                    'The changes in this PR are similar to those in the referenced PR above, which has been selected as the canonical version.',
                    '',
                    'If you believe this PR should be kept instead, please:',
                    '1. Comment below explaining why',
                    '2. Reopen this PR',
                    '3. Tag @itstanner5216 for review',
                    '',
                    '---',
                    '*This action was performed by the PR Consolidation workflow*'
                  ].join('\n')
                });
                
                // Close the PR
                await github.rest.pulls.update({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prInfo.number,
                  state: 'closed'
                });
                
                console.log(`‚úÖ Closed PR #${prInfo.number}`);
              } catch (error) {
                console.error(`‚ùå Failed to close PR #${prInfo.number}: ${error.message}`);
              }
            }

  cleanup-comments:
    name: Phase 2 - Clean Up AI Review Comments
    needs: [analyze-prs, close-duplicate-prs]
    runs-on: ubuntu-latest
    if: |
      always() && 
      (inputs.dry_run == false) && 
      (inputs.auto_cleanup_comments == true || needs.close-duplicate-prs.result == 'success')
    
    steps:
      - name: Delete old AI review comments from remaining PRs
        uses: actions/github-script@v7
        with:
          script: |
            const prsToKeep = JSON.parse('${{ needs.analyze-prs.outputs.prs_to_keep }}');
            
            console.log(`Cleaning up comments on ${prsToKeep.length} PRs...`);
            
            let totalDeleted = 0;
            
            for (const prNumber of prsToKeep) {
              try {
                // Fetch all comments on this PR
                const { data: comments } = await github.rest.issues.listComments({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  per_page: 100
                });
                
                // Find AI review pipeline comments
                const aiComments = comments.filter(comment => 
                  comment.user.type === 'Bot' &&
                  (comment.body.includes('AI-Powered PR Review Pipeline') ||
                   comment.body.includes('Validation Agent') ||
                   comment.body.includes('Remediation Agent') ||
                   comment.body.includes('Architectural Guardian') ||
                   comment.body.includes('Functional Verifier'))
                );
                
                console.log(`PR #${prNumber}: Found ${aiComments.length} AI comments to delete`);
                
                // Delete each AI comment
                for (const comment of aiComments) {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: comment.id
                  });
                  totalDeleted++;
                }
                
                // Add a fresh comment explaining cleanup
                if (aiComments.length > 0) {
                  await github.rest.issues.createComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: prNumber,
                    body: [
                      '## üßπ AI Review Comments Cleaned',
                      '',
                      `Removed ${aiComments.length} outdated AI review comments.`,
                      '',
                      'Fresh AI reviews will be posted shortly with accurate test results.',
                      '',
                      '---',
                      '*Automated by PR Consolidation workflow*'
                    ].join('\n')
                  });
                }
                
              } catch (error) {
                console.error(`Failed to clean comments on PR #${prNumber}: ${error.message}`);
              }
            }
            
            console.log(`\n‚úÖ Total comments deleted: ${totalDeleted}`);
            core.summary.addRaw(`## Comment Cleanup Summary\n\nDeleted **${totalDeleted}** outdated AI review comments from **${prsToKeep.length}** PRs.\n`);
            await core.summary.write();

  rerun-ai-pipeline:
    name: Phase 3 - Re-run AI Review Pipeline
    needs: [analyze-prs, cleanup-comments]
    runs-on: ubuntu-latest
    if: |
      always() && 
      (inputs.dry_run == false) && 
      (inputs.auto_rerun_pipeline == true || needs.cleanup-comments.result == 'success')
    
    steps:
      - name: Trigger AI review pipeline for remaining PRs
        uses: actions/github-script@v7
        with:
          script: |
            const prsToKeep = JSON.parse('${{ needs.analyze-prs.outputs.prs_to_keep }}');
            
            console.log(`Triggering AI review pipeline for ${prsToKeep.length} PRs...`);
            
            // Trigger workflow with comma-separated PR numbers
            const prNumbers = prsToKeep.join(',');
            
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'ai-pr-review-pipeline.yml',
              ref: 'main',
              inputs: {
                pr_numbers: prNumbers,
                agent_mode: 'review_and_fix'
              }
            });
            
            console.log('‚úÖ AI review pipeline triggered');
            console.log(`   PR numbers: ${prNumbers}`);
            
            core.summary.addRaw(`## AI Pipeline Triggered\n\nRe-running AI reviews for **${prsToKeep.length}** consolidated PRs.\n\nPR numbers: ${prNumbers}\n`);
            await core.summary.write();

  summary:
    name: Generate Final Summary
    needs: [analyze-prs, close-duplicate-prs, cleanup-comments, rerun-ai-pipeline]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: Generate workflow summary
        uses: actions/github-script@v7
        with:
          script: |
            const report = JSON.parse('${{ needs.analyze-prs.outputs.consolidation_report }}');
            const prsToKeep = JSON.parse('${{ needs.analyze-prs.outputs.prs_to_keep }}');
            const prsToClose = JSON.parse('${{ needs.analyze-prs.outputs.prs_to_close }}');
            const dryRun = ${{ inputs.dry_run }};
            
            let summary = '# üßπ PR Consolidation & Cleanup Summary\n\n';
            
            if (dryRun) {
              summary += '> **DRY RUN MODE** - No changes were made\n\n';
            }
            
            summary += `## üìä Analysis Results\n\n`;
            summary += `- **Total PRs analyzed:** ${report.total_prs}\n`;
            summary += `- **PRs to keep:** ${report.prs_to_keep}\n`;
            summary += `- **PRs to close:** ${report.prs_to_close}\n\n`;
            
            summary += `## üìÅ Categories\n\n`;
            for (const cat of report.categories) {
              summary += `- **${cat.name}**: ${cat.count} PRs\n`;
            }
            
            summary += `\n## ‚úÖ PRs to Keep (${prsToKeep.length})\n\n`;
            summary += prsToKeep.map(n => `- #${n}`).join('\n');
            
            if (!dryRun) {
              summary += `\n\n## ‚ùå PRs Closed (${prsToClose.length})\n\n`;
              for (const pr of prsToClose) {
                summary += `- #${pr.number}: ${pr.title} (${pr.reason})\n`;
              }
              
              summary += `\n## üéØ Next Steps\n\n`;
              summary += `1. ‚úÖ Duplicate PRs closed\n`;
              summary += `2. ‚úÖ Old AI comments deleted\n`;
              summary += `3. ‚úÖ Fresh AI reviews triggered\n\n`;
              summary += `Check the remaining ${prsToKeep.length} PRs for new AI review comments with accurate test results.\n`;
            } else {
              summary += `\n\n## üéØ Next Steps\n\n`;
              summary += `This was a **dry run**. To execute the consolidation:\n\n`;
              summary += `1. Review the [consolidation report artifact](../artifacts)\n`;
              summary += `2. Re-run this workflow with "Dry run mode" unchecked\n`;
            }
            
            core.summary.addRaw(summary);
            await core.summary.write();
